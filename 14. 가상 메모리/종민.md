# 1. 연속 메모리 할당

## 1-1. 스와핑
- 프로세스를 메모리에서 디스크로, 또는 반대로 옮기는 작업  
- 메모리 공간이 부족할 때 프로세스를 디스크로 잠시 내보냄  
- CPU 사용률 향상 가능하지만, 디스크 접근 속도로 인해 느릴 수 있음

## 1-2. 메모리 할당
- **최초 적합 (First Fit)**  
  빈 공간 중 가장 먼저 적합한 공간에 할당하여 검색 최소화
- **최적 적합 (Best Fit)**  
  빈 공간을 모두 검색 후 가장 작은 공간에 할당
- **최악 적합 (Worst Fit)**  
  빈 공간을 모두 검색 후 가장 큰 공간에 할당

## 1-3. 외부 단편화
- 메모리가 전체적으로는 남아있지만, 작게 나뉜 빈 공간들이 흩어져 있어서 새 프로세스를 넣기 어려운 상황  
- 해결법: 압축(compaction)  
- 단점: 압축 과정에서 부가적 리소스 소모

---

# 2. 페이징을 통한 가상 메모리 관리

## 2-1. 페이징이란
- 메모리를 일정 크기의 고정된 블록인 페이지(Page) 단위로 나누어 관리하는 기법  
- 프로세스의 논리 주소 공간과 물리 메모리를 각각 페이지와 프레임(Frame)으로 나누어 매핑  
- 연속된 메모리 공간이 필요 없으므로 외부 단편화 문제 해결

## 2-2. 페이지 테이블
- 각 프로세스마다 존재하며, 논리 페이지 번호를 물리 프레임 번호에 대응시키는 매핑 정보를 저장하는 자료구조  
- 페이지 테이블을 통해 논리 주소를 물리 주소로 변환

## 2-3. 페이징에서의 주소 변환
- 논리 주소 = 페이지 번호 + 변위(Offset)  
- 변위는 페이지 내 위치를 나타내는 주소 일부로, 페이지 크기에 맞춰 정해진 비트 수만큼의 값  
- 주소 변환 시 페이지 번호로 찾은 프레임 시작 주소에 변위를 더해 실제 물리 주소를 계산함

## 2-4. 페이지 테이블 엔트리
- **유효 비트 (Valid Bit / Present Bit)**  
  페이지가 물리 메모리에 존재하는지 여부  
  - 1: 존재함  
  - 0: 존재하지 않음 (페이지 폴트 발생)  
- **페이지 폴트 비트 (Page Fault Bit)**  
  페이지 폴트 발생 여부 표시 (운영체제에 따라 다름)  
- **보호 비트 (Protection Bit)**  
  읽기/쓰기/실행 권한 설정 (예: 읽기 전용, 쓰기 가능 등)  
- **참조 비트 (Accessed Bit / Referenced Bit)**  
  최근에 해당 페이지가 접근되었는지 표시 (페이지 교체 알고리즘에서 사용)  
- **수정 비트 / 더티 비트 (Dirty Bit)**  
  페이지가 메모리 내에서 수정되었는지 표시  
  - 1: 수정됨 → 디스크에 다시 써야 함  
  - 0: 수정 안 됨

## 2-5. 페이징의 이점 - 쓰기 시 복사 (Copy-on-Write)
- 프로세스를 복사할 때, 메모리 페이지를 즉시 복사하지 않고 읽기 전용 상태로 공유  
- 페이지에 쓰기 작업이 발생할 때 그때서야 실제로 페이지를 복사하여 별도로 관리  
- 메모리 사용 효율이 높아지고, 불필요한 복사를 줄일 수 있음  
- 프로세스 생성(예: fork) 시 빠른 실행과 자원 절약에 유리함

## 2-6. 계층적 페이징 (다단계 페이지 테이블)
- 논리 주소를 바깥 페이지 번호와 안쪽 페이지 번호로 나눔  
- 바깥 페이지 번호는 상위 단계 페이지 테이블을 가리키고,  
- 안쪽 페이지 번호는 하위 단계 페이지 테이블에서 물리 프레임 번호를 찾는 데 사용  
- 여러 단계로 나누어 페이지 테이블 크기를 줄이고 관리 효율을 높임

---

# 3. 페이지 교체와 프레임 할당

## 3-1. 요구 페이징 (Demand Paging)
- 필요한 페이지가 사용될 때만 메모리에 로드하는 기법  
- 메모리 사용 효율이 높아짐

## 3-2. 페이지 교체 알고리즘
- **FIFO (First-In, First-Out)**  
  가장 먼저 메모리에 들어온 페이지를 가장 먼저 교체  
  - 단점: 구현이 간단하지만, 오래된 페이지가 꼭 안 쓰이는 것은 아니어서 비효율적일 수 있음
- **최적 페이지 교체 알고리즘 (Optimal)**  
  앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 이론적 최적 알고리즘  
  - 실제 구현은 어렵지만 성능 비교 기준으로 사용됨
- **LRU (Least Recently Used)**  
  가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘  
  - 실제 사용 패턴을 반영해 FIFO보다 효율적  
  - 구현이 복잡할 수 있으며, 참조 시간 추적이 필요함

## 3-3. 스래싱과 프레임 할당

### 스래싱 (Thrashing)
- 프로세스가 필요한 페이지를 자주 교체하여 페이지 폴트가 빈번히 발생하는 상태  
- CPU가 실제 작업보다 페이지 교체에 더 많은 시간을 쓰면서 시스템 성능이 급격히 저하됨  
- 주로 멀티프로그래밍 정도가 지나치게 높을 때 발생

### 멀티프로그래밍의 정도 (Degree of Multiprogramming)
- 한 번에 메모리에 올라와 실행 중인 프로세스 수  
- 멀티프로그래밍 정도가 너무 높으면 프레임이 부족해 스래싱 발생 가능

### 프레임 할당 방식 (Frame Allocation Methods)
- 프로세스에 물리 메모리 프레임을 어떻게 분배할지 결정하는 방법

1. **균등 할당 (Equal Allocation)**  
   모든 프로세스에 동일한 수의 프레임 할당  
   - 간단하지만, 프로세스별 필요에 따른 차이를 반영하지 못함

2. **비례 할당 (Proportional Allocation)**  
   각 프로세스의 크기(예: 페이지 수)에 비례해 프레임 할당  
   - 큰 프로세스에 더 많은 프레임 배분

### 작업 집합 모델 (Working Set Model)
- 프로세스가 일정 기간 동안 필요로 하는 페이지들의 집합  
- 작업 집합(Working Set)을 충분히 메모리에 할당하면 페이지 폴트 감소 가능  
- 작업 집합 크기를 기반으로 프레임 수 조절하여 스래싱 방지

### 페이지 폴트 빈도 (Page Fault Frequency)
- 프로세스의 페이지 폴트 발생 빈도를 측정해  
- 폴트가 너무 잦으면 프레임을 추가 할당하고, 적으면 줄이는 동적 프레임 조절 기법
