# Chapter 03. 명령어
## 03-1. 소스 코드와 명령어
- 컴퓨터는 명령어를 처리하는 기계다.
- 우리가 작성하는 프로그램(소스 코드)은 컴퓨터가 이해할 수 있는 명령어로 변환되어야 실행된다.
### 고급 언어와 저급언어
- **고급 언어**: 사람이 이해하기 쉽도록 만들어진 언어. 예) Python, Java, C 등
- **저급 언어**: 컴퓨터가 직접 이해하고 실행할 수 있는 언어.
  - **기계어**: 0과 1로 이루어진 명령어(비트 단위). CPU가 직접 해석한다.
  - **어셈블리어**: 기계어를 사람이 읽기 쉽게 기호화한 언어. 각 명령이 기계어와 1:1로 대응된다.
### 고급 언어와 저급 언어의 차이
- 고급 언어는 사람이 쉽게 쓸 수 있고, 여러 환경에서 사용할 수 있다.
- 저급 언어는 하드웨어와 밀접하게 연결되어 있어, 속도가 빠르고 세밀한 제어가 가능하다.
- 고급 언어로 작성된 프로그램은 반드시 **저급 언어로 변환되어야 컴퓨터가 실행할 수 있다.**

### 고급 언어를 저급 언어로 변환하는 방법
- 소스 코드를 저급 언어로 바꾸는 방식에는 두 가지가 있다.

|구분|컴파일 방식|인터프리트 방식|
|---|---|---|
|변환 시점|실행 전, 전체를 한 번에 변환|실행 중, 한 줄씩 변환|
|실행 파일|생성됨|생성되지 않음|
|실행 속도|빠름|느릴 수 있음|
|오류 발견|컴파일 시점|실행 중|
|대표 언어|C, C++|Python, JavaScript 등|

- **컴파일 방식**
  - 소스 코드 전체를 한 번에 저급 언어로 변환(컴파일)해서 실행 파일을 만든다.
  - 컴파일러라는 도구가 이 과정을 담당한다.
  - 컴파일 도중 오류가 있으면 실행 파일이 만들어지지 않는다.
  - 변환된 코드를 목적 코드라고 부른다.
- **인터프리트 방식**
  - 소스 코드를 한 줄씩 읽어가며 바로 실행한다.
  - 인터프리터라는 도구가 이 과정을 담당한다.
  - 실행 파일이 따로 만들어지지 않고, 코드 수정 후 바로 실행할 수 있다.
  - 실행 속도가 컴파일 방식보다 느릴 수 있다.

> **핵심 포인트**
> - 컴퓨터는 오직 0과 1로 된 명령어만 이해한다.
> -  그래서사람이 쓰는 고급 언어는 반드시 저급 언어로 변환되어야 한다.
> - 변환 방식에는 크게 두 가지 방식(컴파일과 인터프리트)이 있다.
> - 각 방식마다 장단점이 있으므로, 목적에 맞게 선택한다.

### 목적 파일 vs 실행 파일
- **목적 파일**: 컴파일 후 만들어지는 중간 결과물. 바로 실행할 수 없다.
- **실행 파일**: 목적 파일들을 링킹(Linking)해서 만든, 실제로 실행 가능한 파일.
- **링킹**: 여러 목적 파일을 합쳐 실행 파일로 만드는 과정.

## 03-2. 명령어의 구조
### 연산 코드와 오퍼랜드
- **명령어**: 연산자와 오퍼랜드로 구성
- **연산코드**(Opcode 연산자): 명령어가 수행할 연산
  - 연산 코드 기능에따라 크게 네 가지 분류할 수 있다.
    - 데이터 전송: MOVE, STORE, LOAD (FETCH), PUSH, POP 등
    - 산술/논리 연산: ADD, SUBSRACT, MULTIPLY, DIVIDE, INCREMENT, DECREMENT, AND, OR, NOT, COMPARE 등
    - 제어 흐름 변경: JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN 등
    - 입출력 제어: READ (INPUT), WRITE (OUTPUT), START IO, TEST IO 등
- **오퍼랜드**(Operand 피연산자): 전산에 사용할 데이터(혹은 그 데이터가 저장된 위치)
  - 0-주소 명령어: 오퍼랜드가 없음
  - 1-주소 명령어: 오퍼랜드가 하나
  - 2-주소 명령어: 오퍼랜드가 둘
  - 3-주소 명령어: 오퍼랜드가 셋
  - 연산에 사용을 데이터를 직접 명시하기보다는 많은 경우 연산에 사용할 데이터가 저장된 위치 즉 메모리 주소나 레지스터 이름이 담김
    - 그래서 오퍼랜드 필드를 주소필드라고 부르기도 함
### 주소 지정 방식
- 왜 오퍼랜드 필드에 주소가 담길까? 데이터 담아도 될텐데 → 명령어 길이 때문!
- 연산이 대상이 되는 데이터가 저장된 위치를 유효주소 라고 한다.
- **즉시 주소 지정 방식**: 연산에 사용할 데이터 (빠른데 표현할 데이터 크기가 좁음)
- **직접 주소 지정 방식**: 유효 주소 (메모리 주소)
- **간접 주소 지정 방식**: 유효 주소의 주소 (두 번의 메모리 접근 필요 → 다소 느림)
- **레지스터 주소 지정 방식**: 유효 주소 (레지스터 이름)
- **레지스터 간접 주소 지정 방식**: 유효 주소를 저장한 레지스터
  - 메모리 접근하는 횟수가 한 번으로 줄어드는 장점!

> 정리
> - 명령어는 연산코드, 오퍼랜드
> - 오퍼랜드는 실제 값 or 주소를 저장
> - 주소 지정 방식은 오퍼랜드의 위치를 해석하는 방식이며 즉시, 직접, 간접, 레지스터, 레지스터 간접 등이 있다.
> - 즉시를 안 쓰고 주소를 사용하는 이유는 명령어 길이로 인한 효율성 때문이다.

